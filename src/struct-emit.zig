pub const AbstTree = struct {
    name: []u8,
    children: ArrayList(Member),

    pub const Member = struct {
        name: []u8,
        kind: []u8,

        pub fn format(self: Member, w: *Writer) !void {
            try w.writeAll("    ");
            try w.writeAll(self.name);
            try w.writeAll(self.kind);
        }
    };

    pub fn init(a: Allocator, name: []const u8) !*AbstTree {
        const self = try a.create(AbstTree);
        self.* = .{
            .name = try a.dupe(u8, name),
            .children = .initBuffer(try a.alloc(Member, 50)),
        };
        return self;
    }

    pub fn exists(self: *AbstTree, name: []const u8) bool {
        for (self.children) |child| {
            if (eql(u8, child.name, name)) return true;
        }
        return false;
    }

    pub fn append(self: *AbstTree, new: Member) !void {
        for (self.children.items) |child| {
            if (eql(u8, child.name, new.name)) {
                if (!eql(u8, child.kind, new.kind)) {
                    std.debug.print("Error: kind mismatch while building ", .{});
                    //var par = self.parent;
                    //while (par != null) {
                    //    par = par.?.parent;
                    //    std.debug.print("{s}.", .{par.?.name});
                    //}

                    std.debug.print(
                        "{s}.{s}\n  {s} != {s}\n",
                        .{ self.name, new.name, child.kind, new.kind },
                    );
                    return error.KindMismatch;
                }
                return;
            }
        }

        try self.children.appendBounded(new);
    }

    pub fn format(self: AbstTree, w: *Writer) !void {
        try w.writeAll("pub const ");
        try w.writeAll(self.name);
        try w.writeAll(" = struct {\n");
        for (self.children.items) |child| {
            try w.print("{f}", .{child});
        }
        try w.writeAll(
            \\
            \\    pub const Translate = AutoTranslate(@This());
            \\    pub const translate = Translate.translate;
            \\    pub const translateAlloc = Translate.translateAlloc;
            \\
        );
        try w.writeAll("};\n");
    }
};

fn AutoTranslate(into: type) type {
    return struct {
        pub const Self = @This();
        pub const To: type = into;
        pub const fields = @typeInfo(To).@"struct".fields;

        pub fn translate(from: anytype) To {
            const From = @TypeOf(from);
            var result: To = undefined;
            inline for (Self.fields) |field| {
                if (!@hasField(From, field.name)) {
                    @compileError("Source struct " ++
                        @typeName(From) ++
                        " is missing required field '" ++ field.name ++
                        "' while translating into " ++
                        @typeName(To));
                }
                @field(result, field.name) = @field(from, field.name);
            }
            return result;
        }

        pub fn translateAlloc(a: std.mem.Allocator, from: anytype) !To {
            _ = a;
            _ = from;
            comptime unreachable;
        }
    };
}

pub var global_tree: StrHashMap(*AbstTree) = .{};
var enum_list: StrHashMap(*EnumLiteral) = .{};
var switch_list: StrHashMap(*Switch) = .{};

pub fn main() !void {
    var args = std.process.args();

    var wout_path: ?[]const u8 = null;
    while (args.next()) |arg| {
        wout_path = arg;
    }

    const a = std.heap.page_allocator;

    const wout_dname = std.fs.path.dirname(wout_path.?) orelse return error.InvalidPath;
    const wout_dir = try std.fs.cwd().openDir(wout_dname, .{});
    var wfile = try wout_dir.createFile(std.fs.path.basename(wout_path.?), .{});
    defer wfile.close();
    const wfile_b = try a.alloc(u8, 0x80000);
    defer a.free(wfile_b);
    var fwriter = wfile.writer(wfile_b);
    var wout = &fwriter.interface;
    defer wout.flush() catch unreachable;
    try wout.writeAll(
        \\//! Generated by verse template compiler
        \\
        \\const std = @import("std");
        \\
        \\fn AutoTranslate(into: type) type {
        \\    return struct {
        \\        pub const Self = @This();
        \\        pub const To: type = into;
        \\        pub const fields = @typeInfo(To).@"struct".fields;
        \\
        \\        pub fn translate(from: anytype) To {
        \\            const From = @TypeOf(from);
        \\            var result: To = undefined;
        \\            inline for (Self.fields) |field| {
        \\                if (!@hasField(From, field.name)) {
        \\                    @compileError("Source struct " ++
        \\                        @typeName(From) ++
        \\                        " is missing required field '" ++ field.name ++
        \\                        "' while translating into " ++
        \\                        @typeName(To));
        \\                }
        \\                @field(result, field.name) = @field(from, field.name);
        \\            }
        \\            return result;
        \\        }
        \\
        \\        pub fn translateAlloc(a: std.mem.Allocator, from: anytype) !To {
        \\            _ = a;
        \\            _ = from;
        \\            comptime unreachable;
        \\        }
        \\    };
        \\}
    );

    for (compiled.data) |tplt| {
        const fdata = std.fs.cwd().readFileAlloc(a, tplt.path, 0xffff) catch |err| br: {
            if (err != error.FileNotFound) {
                std.debug.print("template {s}\n", .{tplt.path});
                std.debug.print("base {s}\n", .{try std.fs.cwd().realpathAlloc(a, ".")});
                return err;
            }

            break :br try a.dupe(u8, tplt.blob);
        };
        defer a.free(fdata);

        const name = makeStructName(tplt.path);
        const this = try AbstTree.init(a, name);
        const gop = try global_tree.getOrPut(a, this.name);
        if (!gop.found_existing) {
            gop.value_ptr.* = this;
        }
        try emitSourceVars(a, fdata, this, &global_tree);
    }

    {
        var itr = global_tree.iterator();
        while (itr.next()) |each| {
            //std.debug.print("tree: {}\n", .{each.value_ptr.*});
            try wout.print("{f}\n", .{each.value_ptr.*});
        }
    }

    {
        var itr = enum_list.iterator();
        while (itr.next()) |each| {
            //std.debug.print("tree: {}\n", .{each.value_ptr.*});
            try wout.print("{f}\n", .{each.value_ptr.*});
        }
    }

    {
        var itr = switch_list.iterator();
        while (itr.next()) |each| {
            //std.debug.print("tree: {}\n", .{each.value_ptr.*});
            try wout.print("{f}\n", .{each.value_ptr.*});
        }
    }
}

fn genType(d: Directive) type {
    std.debug.print("dir {any}\n", .{d});

    return @Type(.{});
}

pub const EnumLiteral = struct {
    name: []const u8,
    text: []const u8,
    members: ArrayList([]const u8) = .{},

    pub fn init(a: Allocator, name: []const u8, text: []const u8) !*EnumLiteral {
        const self = try a.create(EnumLiteral);
        self.* = .{
            .name = try a.dupe(u8, name),
            .text = try a.dupe(u8, text),
        };
        return self;
    }

    pub fn add(el: *EnumLiteral, a: Allocator, tag: []const u8) !void {
        for (el.members.items) |each| {
            if (eql(u8, each, tag)) return;
        }
        try el.members.append(a, try a.dupe(u8, tag));
    }

    pub fn format(el: EnumLiteral, w: *Writer) !void {
        try w.writeAll("pub const ");
        try w.writeAll(el.name);
        try w.writeAll(" = enum(u16) {\n");
        for (el.members.items) |tag| {
            try w.print("    {s},\n", .{tag});
        }
        try w.print("    pub const VALUE = \"{s}\";\n", .{el.text});
        try w.writeAll("};\n");
    }
};

fn createEnumLiteral(a: Allocator, name: []const u8, text: []const u8) !void {
    const lit: *EnumLiteral = try .init(a, name, text);
    try enum_list.put(a, lit.name, lit);
}

fn appendEnumLiteral(a: Allocator, name: []const u8, tag: []const u8) !void {
    if (enum_list.get(name)) |*lit| {
        try lit.*.add(a, tag);
    } else return error.EnumDoesNotExist;
}

pub const Switch = struct {
    name: []const u8,
    text: []const u8,
    members: ArrayList(Case),
    tree: StrHashMap(*AbstTree),

    pub const Case = struct {
        name: []const u8,
        flavor: []const u8,

        pub fn format(c: Case, w: *Writer) !void {
            try w.print("{s}: {s}", .{ c.name, c.flavor });
        }
    };

    pub fn init(a: Allocator, sname: []const u8, text: []const u8) error{ OutOfMemory, WriteError }!*Switch {
        const name = try a.dupe(u8, sname);
        var tree: StrHashMap(*AbstTree) = .{};
        const first = try AbstTree.init(a, name);
        try tree.put(a, first.name, first);

        emitSourceVars(a, text, first, &tree) catch unreachable;
        const self = try a.create(Switch);
        self.* = .{
            .name = name,
            .text = try a.dupe(u8, text),
            .members = .{},
            .tree = tree,
        };
        const kv = tree.fetchRemove(first.name) orelse unreachable;
        for (kv.value.children.items) |child| {
            try self.members.append(a, .{ .name = child.name, .flavor = child.kind });
        }
        // spacer
        return self;
    }

    pub fn format(sw: Switch, w: *Writer) !void {
        try w.writeAll("pub const ");
        try w.writeAll(sw.name);
        try w.writeAll(" = union(enum) {\n");
        for (sw.members.items) |tag| {
            try w.print("{f},\n", .{tag});
        }

        try w.writeAll("\n");
        var itr = sw.tree.iterator();
        while (itr.next()) |each| {
            //std.debug.print("tree: {}\n", .{each.value_ptr.*});
            try w.print("{f}\n", .{each.value_ptr.*});
        }
        try w.writeAll("};\n");
    }
};

fn createSwitch(a: Allocator, name: []const u8, text: []const u8) !void {
    const sw: *Switch = try .init(a, name, text);
    try switch_list.put(a, sw.name, sw);
}

pub fn emitSourceVars(a: Allocator, fdata: []const u8, parent: *AbstTree, root: *StrHashMap(*AbstTree)) !void {
    var data = fdata;
    while (data.len > 0) {
        if (indexOf(u8, data, "<")) |offset| {
            data = data[offset..];
            if (Directive.init(data)) |drct| {
                //_ = genType(drct);
                data = data[drct.tag_block.len..];
                const s_name = makeStructName(drct.noun);
                const f_name = try allocFieldName(a, drct.noun);

                switch (drct.verb) {
                    .variable => |_| {
                        const kind: []u8 = kind: {
                            if (drct.html_type) |htype| {
                                break :kind switch (htype) {
                                    .@"enum" => try allocPrint(a, ": {s},\n", .{s_name}),
                                    .usize,
                                    .isize,
                                    .@"?usize",
                                    => try allocPrint(a, ": {s},\n", .{@tagName(htype)}),
                                    .humanize => try allocPrint(a, ": i64,\n", .{}),
                                };
                            } else {
                                break :kind switch (drct.otherwise) {
                                    .required => try allocPrint(a, ": []const u8,\n", .{}),
                                    .exact => unreachable,
                                    .default => |str| try allocPrint(a, ": []const u8 = \"{s}\",\n", .{str}),
                                    .delete => try allocPrint(a, ": ?[]const u8 = null,\n", .{}),
                                    .template => |_| {
                                        const rf_name = makeFieldName(drct.noun[1 .. drct.noun.len - 5]);
                                        try parent.append(.{
                                            .name = try a.dupe(u8, rf_name),
                                            .kind = try allocPrint(a, ": ?{s},\n", .{s_name}),
                                        });
                                        continue;
                                    },
                                    .literal => |lit| {
                                        try appendEnumLiteral(a, s_name, lit);
                                        break :kind try allocPrint(a, ": []const u8,\n", .{});
                                    },
                                };
                            }
                        };
                        try parent.append(.{ .name = f_name, .kind = kind });
                    },
                    .directive => try createEnumLiteral(a, s_name, drct.otherwise.literal),
                    .@"switch" => {
                        const sw_name = try a.dupe(u8, s_name);
                        try createSwitch(a, sw_name, drct.tag_block_body.?);
                        try parent.append(.{ .name = f_name, .kind = try allocPrint(a, ": {s},\n", .{sw_name}) });
                    },
                    else => |verb| {
                        var this: *AbstTree = try .init(a, s_name);
                        const gop = try root.getOrPut(a, this.name);
                        if (!gop.found_existing) {
                            gop.value_ptr.* = this;
                        } else {
                            this = gop.value_ptr.*;
                        }

                        switch (verb) {
                            .directive => unreachable,
                            .variable => unreachable,
                            .@"switch" => unreachable, // recursive switch not implemented
                            .foreach => {
                                const body_blob: []const u8, const kind: []u8 = switch (drct.otherwise) {
                                    .exact => |exact| .{ drct.tag_block_body.?, try allocPrint(a, ": [{}]{s},\n", .{ exact, s_name }) },
                                    .template => |template| .{ template.blob, try allocPrint(a, ": []const {s},\n", .{s_name}) },
                                    else => .{ drct.tag_block_body.?, try allocPrint(a, ": []const {s},\n", .{s_name}) },
                                };
                                try parent.append(.{ .name = f_name, .kind = kind });
                                try emitSourceVars(a, body_blob, this, root);
                            },
                            .split => {
                                const kind = try allocPrint(a, ": []const []const u8,\n", .{});
                                try parent.append(.{ .name = f_name, .kind = kind });
                            },
                            .case => {
                                const kind = try allocPrint(a, "{s}", .{s_name});
                                try parent.append(.{ .name = f_name, .kind = kind });
                                try emitSourceVars(a, drct.tag_block_body.?, this, root);
                            },
                            .with => {
                                const kind = try allocPrint(a, ": ?{s},\n", .{s_name});
                                try parent.append(.{ .name = f_name, .kind = kind });
                                try emitSourceVars(a, drct.tag_block_body.?, this, root);
                            },
                            .build => {
                                const tmpl_name = makeStructName(drct.otherwise.template.name);
                                const kind = try allocPrint(a, ": {s},\n", .{tmpl_name});
                                try parent.append(.{ .name = f_name, .kind = kind });
                            },
                        }
                    },
                }
            } else if (constructor.commentTag(data)) |skip| {
                data = data[skip..];
            } else if (indexOfPos(u8, data, 1, "<")) |next| {
                data = data[next..];
            } else return;
        } else return;
    }
    return;
}

pub fn allocFieldName(a: Allocator, in: []const u8) ![]u8 {
    const name = makeFieldName(in);
    return try a.dupe(u8, name);
}

pub fn makeFieldName(in: []const u8) []const u8 {
    const local = struct {
        var name: [0xFFFF]u8 = undefined;
    };

    var i: usize = 0;
    for (in) |chr| {
        switch (chr) {
            'a'...'z' => {
                local.name[i] = chr;
                i += 1;
            },
            'A'...'Z' => {
                if (i != 0) {
                    local.name[i] = '_';
                    i += 1;
                }
                local.name[i] = std.ascii.toLower(chr);
                i += 1;
            },
            '0'...'9' => {
                for (intToWord(chr)) |cchr| {
                    local.name[i] = cchr;
                    i += 1;
                }
            },
            '-', '_', '.' => {
                local.name[i] = '_';
                i += 1;
            },
            else => {},
        }
    }

    return local.name[0..i];
}

pub fn makeStructName(in: []const u8) []const u8 {
    const local = struct {
        var name: [0xFFFF]u8 = undefined;
    };

    var tail = in;

    if (std.mem.lastIndexOf(u8, in, "/")) |i| {
        tail = tail[i..];
    }

    var i: usize = 0;
    var next_upper = true;
    for (tail) |chr| {
        switch (chr) {
            'a'...'z', 'A'...'Z' => {
                if (next_upper) {
                    local.name[i] = std.ascii.toUpper(chr);
                } else {
                    local.name[i] = chr;
                }
                next_upper = false;
                i += 1;
            },
            '0'...'9' => {
                for (intToWord(chr)) |cchr| {
                    local.name[i] = cchr;
                    i += 1;
                }
            },
            '-', '_', '.' => {
                next_upper = true;
            },
            else => {},
        }
    }

    return local.name[0..i];
}

fn intToWord(in: u8) []const u8 {
    return switch (in) {
        '0' => "Zero",
        '1' => "One",
        '2' => "Two",
        '3' => "Three",
        '4' => "Four",
        '5' => "Five",
        '6' => "Six",
        '7' => "Seven",
        '8' => "Eight",
        '9' => "Nine",
        else => unreachable,
    };
}

const std = @import("std");
const Allocator = std.mem.Allocator;
const ArrayList = std.ArrayList;
const StrHashMap = std.StringHashMapUnmanaged;
const Writer = std.Io.Writer;
const eql = std.mem.eql;
const bufPrint = std.fmt.bufPrint;
const allocPrint = std.fmt.allocPrint;
const indexOf = std.mem.indexOf;
const indexOfPos = std.mem.indexOfPos;
const compiled = @import("comptime_templates");
const Directive = @import("template/directive.zig");
const constructor = @import("template/constructor.zig");
