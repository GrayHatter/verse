pub const AbstTree = struct {
    name: []u8,
    children: ArrayList(Member),
    trees: StrHashMap(*AbstTree),

    pub const Member = struct {
        name: []u8,
        kind: []u8,

        pub fn format(m: Member, w: *Writer) !void {
            try w.print("    {s}: {s},\n", .{ m.name, m.kind });
        }
    };

    pub fn init(a: Allocator, name: []const u8) !*AbstTree {
        const self = try a.create(AbstTree);
        self.* = .{
            .name = try a.dupe(u8, name),
            .children = .initBuffer(try a.alloc(Member, 50)),
            .trees = .{},
        };
        return self;
    }

    pub fn exists(self: *AbstTree, name: []const u8) bool {
        for (self.children) |child| {
            if (eql(u8, child.name, name)) return true;
        }
        return false;
    }

    pub fn append(self: *AbstTree, new: Member) !void {
        for (self.children.items) |child| {
            if (eql(u8, child.name, new.name)) {
                if (!eql(u8, child.kind, new.kind)) {
                    std.debug.print("Error: kind mismatch while building ", .{});
                    //var par = self.parent;
                    //while (par != null) {
                    //    par = par.?.parent;
                    //    std.debug.print("{s}.", .{par.?.name});
                    //}

                    std.debug.print(
                        "{s}.{s}\n  {s} != {s}\n",
                        .{ self.name, new.name, child.kind, new.kind },
                    );
                    return error.KindMismatch;
                }
                return;
            }
        }

        try self.children.appendBounded(new);
    }

    pub fn format(at: AbstTree, w: *Writer) !void {
        try w.writeAll("pub const ");
        try w.writeAll(at.name);
        try w.writeAll(" = struct {\n");
        for (at.children.items) |child| {
            try w.print("{f}", .{child});
        }
        try w.writeAll(
            \\
            \\    pub const translate = AutoTranslate(@This()).translate;
            \\    pub const translateAlloc = AutoTranslate(@This()).translateAlloc;
            \\
        );
        var itr = at.trees.iterator();
        while (itr.next()) |each| {
            //std.debug.print("tree: {}\n", .{each.value_ptr.*});
            try w.print("{f}\n", .{each.value_ptr.*});
        }

        try w.writeAll("};\n");
    }
};

fn AutoTranslate(into: type) type {
    return struct {
        pub const Self = @This();
        pub const To: type = into;
        pub const fields = @typeInfo(To).@"struct".fields;

        pub fn translate(from: anytype) To {
            const From = @TypeOf(from);
            var result: To = undefined;
            inline for (Self.fields) |field| {
                if (!@hasField(From, field.name)) {
                    @compileError("Source struct " ++
                        @typeName(From) ++
                        " is missing required field '" ++ field.name ++
                        "' while translating into " ++
                        @typeName(To));
                }
                @field(result, field.name) = @field(from, field.name);
            }
            return result;
        }

        pub fn translateAlloc(a: std.mem.Allocator, from: anytype) !To {
            _ = a;
            _ = from;
            comptime unreachable;
        }
    };
}

pub var global_tree: StrHashMap(*AbstTree) = .{};
var enum_list: StrHashMap(*EnumLiteral) = .{};
var switch_list: StrHashMap(*Switch) = .{};

pub fn main() !void {
    var args = std.process.args();

    var wout_path: ?[]const u8 = null;
    while (args.next()) |arg| {
        wout_path = arg;
    }

    const a = std.heap.page_allocator;
    var threaded: std.Io.Threaded = .init_single_threaded;
    const io = threaded.ioBasic();
    const cwd = std.Io.Dir.cwd();

    const wout_dname = std.fs.path.dirname(wout_path.?) orelse return error.InvalidPath;
    const wout_dir = try std.fs.cwd().openDir(wout_dname, .{});
    var wfile = try wout_dir.createFile(std.fs.path.basename(wout_path.?), .{});
    defer wfile.close();
    const wfile_b = try a.alloc(u8, 0x80000);
    defer a.free(wfile_b);
    var fwriter = wfile.writer(wfile_b);
    var wout = &fwriter.interface;
    defer wout.flush() catch unreachable;
    try wout.writeAll(
        \\//! Generated by verse template compiler
        \\
        \\const std = @import("std");
        \\
        \\fn AutoTranslate(into: type) type {
        \\    return struct {
        \\        pub const Self = @This();
        \\        pub const To: type = into;
        \\        pub const fields = @typeInfo(To).@"struct".fields;
        \\
        \\        pub fn translate(from: anytype) To {
        \\            const From = @TypeOf(from);
        \\            var result: To = undefined;
        \\            inline for (Self.fields) |field| {
        \\                if (!@hasField(From, field.name)) {
        \\                    @compileError("Source struct " ++
        \\                        @typeName(From) ++
        \\                        " is missing required field '" ++ field.name ++
        \\                        "' while translating into " ++
        \\                        @typeName(To));
        \\                }
        \\                @field(result, field.name) = @field(from, field.name);
        \\            }
        \\            return result;
        \\        }
        \\
        \\        pub fn translateAlloc(a: std.mem.Allocator, from: anytype) !To {
        \\            _ = a;
        \\            _ = from;
        \\            comptime unreachable;
        \\        }
        \\    };
        \\}
    );

    for (compiled.data) |tplt| {
        const name = makeStructName(tplt.path);
        const this = try AbstTree.init(a, name);
        const gop = try global_tree.getOrPut(a, this.name);
        if (!gop.found_existing) {
            gop.value_ptr.* = this;
        }

        var r_b: [0x8000]u8 = undefined;

        if (cwd.openFile(io, tplt.path, .{})) |file| {
            defer file.close(io);
            var reader = file.reader(io, &r_b);
            reader.interface.fillMore() catch |err| if (err != error.EndOfStream) return err;
            try emitSourceVars(a, &reader.interface, this, &global_tree);
        } else |_| {
            var reader: Reader = .fixed(tplt.blob);
            try emitSourceVars(a, &reader, this, &global_tree);
        }
    }

    {
        var itr = global_tree.iterator();
        while (itr.next()) |each| {
            //std.debug.print("tree: {}\n", .{each.value_ptr.*});
            try wout.print("{f}\n", .{each.value_ptr.*});
        }
    }

    {
        var itr = enum_list.iterator();
        while (itr.next()) |each| {
            //std.debug.print("tree: {}\n", .{each.value_ptr.*});
            try wout.print("{f}\n", .{each.value_ptr.*});
        }
    }

    {
        var itr = switch_list.iterator();
        while (itr.next()) |each| {
            //std.debug.print("tree: {}\n", .{each.value_ptr.*});
            try wout.print("{f}\n", .{each.value_ptr.*});
        }
    }
}

fn genType(d: Directive) type {
    std.debug.print("dir {any}\n", .{d});

    return @TypeOf(.{});
}

pub const EnumLiteral = struct {
    name: []const u8,
    text: []const u8,
    members: ArrayList([]const u8) = .{},

    pub fn init(a: Allocator, name: []const u8, text: []const u8) !*EnumLiteral {
        const self = try a.create(EnumLiteral);
        self.* = .{
            .name = try a.dupe(u8, name),
            .text = try a.dupe(u8, text),
        };
        return self;
    }

    pub fn add(el: *EnumLiteral, a: Allocator, tag: []const u8) !void {
        for (el.members.items) |each| {
            if (eql(u8, each, tag)) return;
        }
        try el.members.append(a, try a.dupe(u8, tag));
    }

    pub fn format(el: EnumLiteral, w: *Writer) !void {
        try w.writeAll("pub const ");
        try w.writeAll(el.name);
        try w.writeAll(" = enum(u16) {\n");
        for (el.members.items) |tag| {
            try w.print("    {s},\n", .{tag});
        }
        try w.print("    pub const VALUE = \"{s}\";\n", .{el.text});
        try w.writeAll("};\n");
    }
};

fn createEnumLiteral(a: Allocator, name: []const u8, text: []const u8) !void {
    const lit: *EnumLiteral = try .init(a, name, text);
    try enum_list.put(a, lit.name, lit);
}

fn appendEnumLiteral(a: Allocator, name: []const u8, tag: []const u8) !void {
    if (enum_list.get(name)) |lit| {
        try lit.add(a, tag);
    } else return error.EnumDoesNotExist;
}

pub const Switch = struct {
    name: []const u8,
    text: []const u8,
    members: ArrayList(Case),
    tree: StrHashMap(*AbstTree),

    pub const Case = struct {
        name: []const u8,
        flavor: []const u8,

        pub fn format(c: Case, w: *Writer) !void {
            try w.print("{s}: {s}", .{ c.name, c.flavor });
        }
    };

    pub fn init(a: Allocator, sname: []const u8, text: []const u8) error{ OutOfMemory, WriteError }!*Switch {
        const name = try a.dupe(u8, sname);
        var tree: StrHashMap(*AbstTree) = .{};
        const first = try AbstTree.init(a, name);
        try tree.put(a, first.name, first);

        var body: Reader = .fixed(text);
        emitSourceVars(a, &body, first, &tree) catch unreachable;
        const self = try a.create(Switch);
        self.* = .{
            .name = name,
            .text = try a.dupe(u8, text),
            .members = .{},
            .tree = tree,
        };
        const kv = tree.fetchRemove(first.name) orelse unreachable;
        for (kv.value.children.items) |child| {
            try self.members.append(a, .{ .name = child.name, .flavor = child.kind });
        }
        // spacer
        return self;
    }

    pub fn format(sw: Switch, w: *Writer) !void {
        try w.writeAll("pub const ");
        try w.writeAll(sw.name);
        try w.writeAll(" = union(enum) {\n");
        for (sw.members.items) |tag| {
            try w.print("{f},\n", .{tag});
        }

        try w.writeAll("\n");
        var itr = sw.tree.iterator();
        while (itr.next()) |each| {
            //std.debug.print("tree: {}\n", .{each.value_ptr.*});
            try w.print("{f}\n", .{each.value_ptr.*});
        }
        try w.writeAll("};\n");
    }
};

fn createSwitch(a: Allocator, name: []const u8, text: []const u8) !void {
    const sw: *Switch = try .init(a, name, text);
    try switch_list.put(a, sw.name, sw);
}

fn htmlType(a: Allocator, html_type: ?Directive.HtmlType, struct_name: []const u8) ![]u8 {
    if (html_type) |htype| {
        return switch (htype) {
            .@"enum" => try a.dupe(u8, struct_name),
            .usize,
            .isize,
            .@"?usize",
            => try a.dupe(u8, @tagName(htype)),
            .humanize => try a.dupe(u8, "i64"),
        };
    } else {
        return try a.dupe(u8, "[]const u8");
    }
}

pub fn emitSourceVars(a: Allocator, ir: *Reader, parent: *AbstTree, root: *StrHashMap(*AbstTree)) !void {
    while (ir.bufferedLen() > 0) {
        _ = try ir.discardDelimiterExclusive('<');
        const str = ir.buffered();
        std.debug.assert(str.len == 0 or str[0] == '<');
        if (Directive.init(ir.buffered())) |drct| {
            ir.toss(drct.tag_block.len);
            const s_name = makeStructName(drct.noun);
            const f_name = try allocFieldName(a, drct.noun);

            switch (drct.verb) {
                .variable => |_| {
                    const kind: []u8 = switch (drct.otherwise) {
                        .required => try htmlType(a, drct.html_type, s_name),
                        .exact => unreachable,
                        .default => |default| try allocPrint(a, "[]const u8 = \"{s}\"", .{default}),
                        .delete => if (drct.html_type) |_|
                            try htmlType(a, drct.html_type, s_name)
                        else
                            try allocPrint(a, "?[]const u8 = null", .{}),
                        .template => |_| {
                            const rf_name = makeFieldName(drct.noun[1 .. drct.noun.len - 5]);
                            try parent.append(.{
                                .name = try a.dupe(u8, rf_name),
                                .kind = try allocPrint(a, "?{s}", .{s_name}),
                            });
                            continue;
                        },
                        .literal => |lit| kind: {
                            try appendEnumLiteral(a, s_name, lit);
                            break :kind try htmlType(a, drct.html_type, s_name);
                        },
                    };

                    try parent.append(.{ .name = f_name, .kind = kind });
                },
                .directive => try createEnumLiteral(a, s_name, drct.otherwise.literal),
                .@"switch" => {
                    const sw_name = try a.dupe(u8, s_name);
                    try createSwitch(a, sw_name, drct.tag_block_body.?);
                    try parent.append(.{ .name = f_name, .kind = try a.dupe(u8, sw_name) });
                },
                else => |verb| {
                    const tree: *StrHashMap(*AbstTree) = if (drct.scope == .global)
                        root
                    else
                        &parent.trees;

                    switch (verb) {
                        .directive => unreachable,
                        .variable => unreachable,
                        .@"switch" => unreachable, // recursive switch not implemented
                        .foreach => {
                            const body_blob: []const u8, const kind: []u8 = switch (drct.otherwise) {
                                .exact => |exact| .{ drct.tag_block_body.?, try allocPrint(a, "[{}]{s}", .{ exact, s_name }) },
                                .template => |template| .{ template.blob, try allocPrint(a, "[]const {s}", .{s_name}) },
                                else => .{ drct.tag_block_body.?, try allocPrint(a, "[]const {s}", .{s_name}) },
                            };
                            try parent.append(.{ .name = f_name, .kind = kind });

                            const gop = try tree.getOrPut(a, s_name);
                            if (!gop.found_existing) gop.value_ptr.* = try .init(a, s_name);
                            const this: *AbstTree = gop.value_ptr.*;

                            var body: Reader = .fixed(body_blob);
                            try emitSourceVars(a, &body, this, tree);
                        },
                        .split => {
                            const kind = try allocPrint(a, "[]const []const u8", .{});
                            try parent.append(.{ .name = f_name, .kind = kind });
                        },
                        .case => {
                            const kind = try a.dupe(u8, s_name);
                            try parent.append(.{ .name = f_name, .kind = kind });

                            const gop = try root.getOrPut(a, s_name);
                            if (!gop.found_existing) gop.value_ptr.* = try .init(a, s_name);
                            const this: *AbstTree = gop.value_ptr.*;

                            var body: Reader = .fixed(drct.tag_block_body.?);
                            try emitSourceVars(a, &body, this, tree);
                        },
                        .with => {
                            const kind = try allocPrint(a, "?{s}", .{s_name});
                            try parent.append(.{ .name = f_name, .kind = kind });

                            const gop = try tree.getOrPut(a, s_name);
                            if (!gop.found_existing) gop.value_ptr.* = try .init(a, s_name);
                            const this: *AbstTree = gop.value_ptr.*;

                            var body: Reader = .fixed(drct.tag_block_body.?);
                            try emitSourceVars(a, &body, this, tree);
                        },
                        .build => {
                            const tmpl_name = makeStructName(drct.otherwise.template.name);
                            const kind = try a.dupe(u8, tmpl_name);
                            try parent.append(.{ .name = f_name, .kind = kind });
                        },
                    }
                },
            }
        } else if (constructor.commentTag(str)) |skip| {
            ir.toss(skip);
        } else {
            if (ir.buffered().len == 0) return;
            ir.toss(1);
        }
    }
    return;
}

pub fn allocFieldName(a: Allocator, in: []const u8) ![]u8 {
    const name = makeFieldName(in);
    return try a.dupe(u8, name);
}

pub fn makeFieldName(in: []const u8) []const u8 {
    const local = struct {
        var name: [0xFFFF]u8 = undefined;
    };

    var i: usize = 0;
    for (in) |chr| {
        switch (chr) {
            'a'...'z' => {
                local.name[i] = chr;
                i += 1;
            },
            'A'...'Z' => {
                if (i != 0) {
                    local.name[i] = '_';
                    i += 1;
                }
                local.name[i] = std.ascii.toLower(chr);
                i += 1;
            },
            '0'...'9' => {
                for (intToWord(chr)) |cchr| {
                    local.name[i] = cchr;
                    i += 1;
                }
            },
            '-', '_', '.' => {
                local.name[i] = '_';
                i += 1;
            },
            else => {},
        }
    }

    return local.name[0..i];
}

pub fn makeStructName(in: []const u8) []const u8 {
    const local = struct {
        var name: [0xFFFF]u8 = undefined;
    };

    var tail = in;

    if (std.mem.lastIndexOf(u8, in, "/")) |i| {
        tail = tail[i..];
    }

    var i: usize = 0;
    var next_upper = true;
    for (tail) |chr| {
        switch (chr) {
            'a'...'z', 'A'...'Z' => {
                if (next_upper) {
                    local.name[i] = std.ascii.toUpper(chr);
                } else {
                    local.name[i] = chr;
                }
                next_upper = false;
                i += 1;
            },
            '0'...'9' => {
                for (intToWord(chr)) |cchr| {
                    local.name[i] = cchr;
                    i += 1;
                }
            },
            '-', '_', '.' => {
                next_upper = true;
            },
            else => {},
        }
    }

    return local.name[0..i];
}

fn intToWord(in: u8) []const u8 {
    return switch (in) {
        '0' => "Zero",
        '1' => "One",
        '2' => "Two",
        '3' => "Three",
        '4' => "Four",
        '5' => "Five",
        '6' => "Six",
        '7' => "Seven",
        '8' => "Eight",
        '9' => "Nine",
        else => unreachable,
    };
}

const std = @import("std");
const Allocator = std.mem.Allocator;
const ArrayList = std.ArrayList;
const StrHashMap = std.StringHashMapUnmanaged;
const Reader = std.Io.Reader;
const Writer = std.Io.Writer;
const eql = std.mem.eql;
const bufPrint = std.fmt.bufPrint;
const allocPrint = std.fmt.allocPrint;
const indexOf = std.mem.indexOf;
const indexOfPos = std.mem.indexOfPos;
const compiled = @import("comptime_templates");
const Directive = @import("template/directive.zig");
const constructor = @import("template/constructor.zig");
